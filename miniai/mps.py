# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/12_mps.ipynb.

# %% auto 0
__all__ = ['ReseedCB', 'cache_dataset_as_dict']

# %% ../nbs/12_mps.ipynb 2
import torch, os
import fastcore.all as f
# [W ParallelNative.cpp:229] Warning: Cannot set number of intraop threads after parallel 
# work has started or after set_num_threads call when using native parallel backend (function set_num_threads)
# Alternative if we won't find a way to use mutliprocessing with MPS:
if torch.backends.mps.is_available():
    if (k:='OMP_NUM_THREADS') not in os.environ: os.environ[k]='1'
    if (k:='PYTORCH_ENABLE_MPS_FALLBACK') not in os.environ: os.environ[k]='1'

# %% ../nbs/12_mps.ipynb 3
from .init import init_weights
from .activations import set_seed
from .learner import Callback


# %% ../nbs/12_mps.ipynb 8
if torch.backends.mps.is_available():
    def init_weights(m, *args, **kwargs):
        from miniai.init import init_weights as init
        devs = [p.device for p in m.parameters()]
        try:
            m.to('cpu')
            return init(m, *args, **kwargs)
        finally:
            for p,d in zip(m.parameters(), devs): m.to(d)

# %% ../nbs/12_mps.ipynb 11
class ReseedCB(Callback):
    order = 0
    def __init__(self): self.gen, self.new_seed = torch.Generator(), None
    def before_fit(self, learn): 
        self.set_seed(self.new_seed)
        print('Using seed', self.new_seed)
    def set_seed(self, seed=None): 
        if seed is None: 
            self.new_seed = torch.randint(2**31, [1], generator=self.gen).item()
            print(f"New seed: {self.new_seed}")
        else:
            self.new_seed = seed
        set_seed(self.new_seed)
        return self.new_seed
    def previous(self): self.set_seed(self.new_seed)
    def new(self): self.set_seed()

# %% ../nbs/12_mps.ipynb 19
# if spawn is not possible, we can cache the entire dataset in memory after transformations
def _with_features(ds):
    setattr((l:=fc.L(ds)), 'features', ds.features)
    return l 
def cache_dataset_as_dict(dd): return {dsn: _with_features(ds) for dsn,ds in dd.items()}
